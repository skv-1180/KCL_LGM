{
	"Cell": {
		"prefix": "node",
		"scope": "cpp",
		"body": [
		   "template<class T>class node{",
		   "\tpublic:",
		   "\t\tT data;",
		   "\t\tnode*next=NULL;",
		   "\t\tnode*previous=NULL;",
		   "\t\tnode(int x=0){",
		   "\t\t\tdata=x;",
		   "\t\t}",
		   "};",
		],
		"description": "data structures."
	},
	"Sparce Table": {
		"prefix": "sparce",
		"scope": "cpp",
		"body": [
		  "//evaluates f(v[l],v[l+1],...,v[r]) as query(l,r)",
		  "//T.C.:O(Nlog(N)) M.C.(Nlog(N))",
		  "vector<vector<int>>sp(log2(L)+1,vector<int>(L));",
		  "void generate_sp(vector<int>&v,function<int(int,int)>f){",
		  "    for(int i=0;i<v.size();i++)sp[0][i]=v[i];",
		  "    for(int j=1;j<=log2(v.size());j++){",
		  "        for(int i=0;i+(1<<j)-1<v.size();i++){",
		  "            sp[j][i]=f(sp[j-1][i],sp[j-1][i+(1<<(j-1))]);",
		  "        }",
		  "    }",
		  "}",
		  "//excessing all the evaluated expresions",
		  "//T.C.:O(1)  M.C.:O(1) (NOTE:r>=l)",
		  "int query(int l,int r,function<int(int,int)>f){",
		  "    if(l>r)swap(l,r);",
		  "    int length=r-l+1,k=0;",
		  "    while((1<<(k+1))<=length)k++;",
		  "    return f(sp[k][l],sp[k][r-(1<<k)+1]);",
		  "}",
		  "int f(int a,int b){",
		  "    return max(a,b);",
		  "}"
		],
		"description": "Sparce Table"
	  },
	  "Segment Tree": {
		"prefix": "segmentree",
		"scope": "cpp",
		"body": [
		  "//Preprocessing:T.C.:O(N)      M.C.:O(4*N)",
		  "//excessing    :T.C.:O(log(N)) M.C.:O(1)",
		  "//note your vector should be 1 indexed and query 1 indexed;",
		  "class st{",
		  "    private:",
		  "        int id = 0;//identity of func f",
		  "        vector<int>t;int n=0;int si=0;",
		  "        int f(int a,int b){",
		  "            return (a+b);",
		  "        }",
		  "        void build(vector<int>&a, int v, int tl, int tr) {",
		  "            if (tl == tr)t[v] = a[tl];",
		  "            else {",
		  "                int tm = (tl + tr) / 2;",
		  "                build(a, v*2, tl, tm);",
		  "                build(a, v*2+1, tm+1, tr);",
		  "                t[v] = f(t[v*2] , t[v*2+1]);",
		  "            }",
		  "        }",
		  "        ",
		  "        int func(int v, int tl, int tr, int l, int r){",
		  "            if (l > r) return id;",
		  "            if (l == tl && r == tr)return t[v];",
		  "            int tm = (tl + tr)>>1;",
		  "            return f(func(v*2, tl, tm, l, min(r, tm)),func(v*2+1, tm+1, tr, max(l, tm+1), r));",
		  "        }",
		  "        void modify(int v, int tl, int tr, int pos, int new_val) {",
		  "            if (tl == tr) t[v] = new_val;",
		  "            else {",
		  "                int tm = (tl + tr) / 2;",
		  "                if (pos <= tm)modify(v*2, tl, tm, pos, new_val);",
		  "                else     modify(v*2+1,tm+1,tr,pos, new_val);",
		  "                t[v] = f(t[v*2] , t[v*2+1]);",
		  "            }",
		  "        }",
		  "    public:",
		  "        st(vector<int>&a,int MAXN){",
		  "            t.resize(4*MAXN);si=1;n=a.size();//n=n+1",
		  "            build(a,1ll,si,n-1);",
		  "            // debug(t)",
		  "        }",
		  "        void update(int position,int new_value){",
		  "            modify(1ll,si,n-1,position,new_value);",
		  "        }",
		  "        int query(int l,int r){",
		  "            return func(1ll,si,n-1,l,r);",
		  "        }",
		  "};",
		  "//st s(v,10);//v is your vector 10 is its max size",
		  "//s.query(2,5);//it will give f aplied at 2 ,3 , 4,5",
		  "//s.update(a,b);//it will update ath number to b in our data",
		  "//for convertig to 0 indexing make si=0 && take input as 0 indexing and pass --l,--r,--u//u->update index",
		],
		"description": "segment_tree"
	  },
	  "Nearest Greater left and right": {
		"prefix": "nearestGreater",
		"scope": "cpp",
		"body": [
		  "//T.C:O(N)  M.C:O(4*N);",
		  "vector<pair<int,int>> nearestGreater(vector<int> &v){",
		  "    stack<int>sl,sr;vector<pair<int,int>> ans(v.size());",
		  "    sl.push(0);sr.push(v.size());v[0]=INF;v.push_back(INF);",
		  "    for(int i=1;i<v.size()-1;i++){",
		  "        while (v[sl.top()]<=v[i])sl.pop();",
		  "        while (v[sr.top()]<=v[v.size()-1-i])sr.pop();",
		  "        ans[i].first=sl.top();",
		  "        ans[v.size()-1-i].second=sr.top();",
		  "        sl.push(i);sr.push(v.size()-1-i);",
		  "    }",
		  "    v.pop_back();",
		  "    return ans;",
		  "}",
		  ""
		],
		"description": "Nearest Greater left and right"
	  }
}