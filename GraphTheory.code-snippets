{
	"Graph":{
		"prefix": "graph",
		"scope": "cpp",
		"body": [
		  "vector<vector<int>> adj;//int-->pair<int,int>==>{value,weight}",
		  "vector<pair<int,int>>moves{};//for matrix form of graph.",
		  "vector<bool> vis;",
		  "//d[i]-->distance of i from source node",
		  "//par[i]-->parent of i",
		  "vector<int> time_in, time_out;",
		  "vector<int> d, parent;",
		  "void input(int n,int e=-1){",
		  "  adj.resize(n+1);",
		  "  vis.resize(n+1);",
		  "  if(e==-1)e=n-1;//tree",
		  "  for(int i=0;i<e;++i){",
		  "\t int v1,v2;",
          "\t cin>>v1>>v2;",
          "\t adj[v1].push_back(v2);",
          "\t adj[v2].push_back(v1);",
		  "  }",
		  "}",
		  "void reset(int n){",
		  "    for(int i=1;i<=n;i++){",
		  "       d[i]=0;parent[i]=0;//bfs",
		  "       vis[i]=0;",
		  "       time_in[i]=0;time_out[i]=0;//dfs",
		  "       adj[i].clear();",
		  "    }",
		  "}"
		],
		"description": ""
	},
	"Depth First Search": {
		"prefix": "dfs",
		"scope": "cpp",
		"body": [
		  
		  "int dfs_timer = 0;",
		  "//T.C.:O(N+E),M.C.:O(N)",
		  "void dfs(int v,int rsz=1) {",
		  "    int n=adj.size();",
		  "    if(rsz)time_in.resize(n);time_out.resize(n);",
		  "    time_in[v] = dfs_timer++;",
		  "    vis[v] = 1;",
		  "    for (int u : adj[v]){",
		  "        if(vis[u] == 0){",
		  "            dfs(u,0);",
		  "        }",
		  "    }",
		  "    vis[v] = 2;",
		  "    time_out[v] = dfs_timer++;",
		  "}"
		],
		"description": "Depth First Search"
	  },
	"Bredth First Search": {
		"prefix": "bfs",
		"scope": "cpp",
		"body": [
		  "//search nodes level wise",
		  "//T.C.:O(NODE) M.C.:O(1)",
		  "template<class T>void bfs(T source){",
		  "    int n=adj.size();",
		  "    parent.resize(n);d.resize(n)",
		  "    queue<T> q;",
		  "    q.push(source);",
		  "    vis[source] = true;",
		  "    parent[source] = -1;",
		  "    while (!q.empty()) {",
		  "        T v = q.front();",
		  "        q.pop();",
		  "        for (auto child : adj[v]) {",
		  "            if (vis[child]) continue;",
		  "                vis[child] = true;",
		  "                q.push(child);",
		  "                d[child] = d[v] + 1;",
		  "                parent[child] = v;",
		  "        }",
		  "    }",
		  "}",
		  "//shortest path from source to node n",
		  "//T.C.:O(N) M.C.:O(N)",
		  "vector<int> path(int node){",
		  "    if (!vis[node]) return {};",
		  "         else {",
		  "        vector<int> pat;",
		  "        for (int v = node; v != -1; v = parent[v])pat.push_back(v);",
		  "        reverse(begin(pat),end(pat));",
		  "        return pat;",
		  "    }",
		  "}",
		  "",
		  
		],
		"description": ""
	  },
	  "Dijkstra Algorithm": {
		"prefix": "dijkistra",
		"scope": "cpp",
		"body": [
		  "//T.C.:O((N+E)log(N)) M.C.:O(N);",
		  "void dijkstra(int source, vector<int> & ShortestDistance, vector<int> & parent){",
		  "    int n = adj.size();",
		  "    ShortestDistance.assign(n, INF);",
		  "    parent.assign(n, -1);",
		  "",
		  "    ShortestDistance[source] = 0;",
		  "    using pii = pair<int, int>;",
		  "    priority_queue<pii, vector<pii>, greater<pii>> q;",
		  "    q.push({0, source});",
		  "    while (!q.empty()) {",
		  "        int v = q.top().second;",
		  "        int ShortestDistance_v = q.top().first;",
		  "        q.pop();",
		  "        if (ShortestDistance_v != ShortestDistance[v])continue;",
		  "        for (auto edge : adj[v]){",
		  "            int to = edge.first;",
		  "            int len = edge.second;",
		  "            if (ShortestDistance[v] + len < ShortestDistance[to]){",
		  "                ShortestDistance[to] = ShortestDistance[v] + len;",
		  "                parent[to] = v;",
		  "                q.push({ShortestDistance[to], to});",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Dijkstra Algorithm"
	  },
	  "Floyd Warshall Algorithm": {
		"prefix": "floydwarshall",
		"scope": "cpp",
		"body": [
		  "//T.C.:O(N^3) M.C.:O(N+E)",
		  "vector<vector<int>>ShortDistance;",
		  "void FloydWarshall(int n,int edges){",
		  "    ShortDistance.resize(n+1,vector<int>(n+1,INF));",
		  "    adj.resize(n+1);",
		  "    for(int i=1;i<=n;i++){",
		  "        ShortDistance[i][i]=0;",
		  "    }",
		  "    for(int i=0;i<edges;i++){",
		  "        int x,y,wt;",
		  "        cin>>x>>y>>wt;",
		  "        ShortDistance[x][y]=min(ShortDistance[x][y],wt);",
		  "        adj[x].push_back({y,wt});",
		  "        ShortDistance[y][x]=min(ShortDistance[x][y],wt);//for undirected",
		  "        adj[y].push_back({x,wt});//for undirected",
		  "",
		  "    }",
		  "    for(int k=1;k<=n;++k){",
		  "        for(int i=1;i<=n;i++){",
		  "            for(int j=1;j<=n;j++){",
		  "                if (ShortDistance[i][k] < INF && ShortDistance[k][j] < INF)",
		  "                ShortDistance[i][j] = min(ShortDistance[i][j],ShortDistance[i][k]+ShortDistance[k][j]);",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Floyd Warshall Algorithm"
	  },
	  "Cycle Detector": {
		"prefix": "cycle",
		"scope": "cpp",
		"body": [
		  "int cycle_start,cycle_end;",
		  "bool dfs(int v, int par) { // passing vertex and its parent vertex",
		  "    vis[v] = true;",
		  "    for (int u : adj[v]) {",
		  "        if(u == par) continue; // skipping edge to parent vertex",
		  "        if (vis[u]) {",
		  "            cycle_end = v;",
		  "            cycle_start = u;",
		  "            return true;",
		  "        }",
		  "        parent[u] = v;",
		  "        if (dfs(u, parent[u]))",
		  "            return true;",
		  "    }",
		  "    return false;",
		  "}",
		  "T.C.:O(E) M.C,:O(N)",
		  "vector<int> find_cycle(int n) {",
		  "    vis.assign(n+1, false);",
		  "    parent.assign(n+1, -1);",
		  "    cycle_start = -1;",
		  "",
		  "    for (int v = 1; v <= n; v++) {",
		  "        if (!vis[v] && dfs(v, parent[v]))",
		  "            break;",
		  "    }",
		  "",
		  "    if (cycle_start == -1) {",
		  "        return {};",
		  "    } else {",
		  "        vector<int> cycle;",
		  "        cycle.push_back(cycle_start);",
		  "        for (int v = cycle_end; v != cycle_start; v = parent[v])",
		  "            cycle.push_back(v);",
		  "        cycle.push_back(cycle_start);",
		  "        return cycle;",
		  "    }",
		  "}"
		],
		"description": "Cycle Detector"
	  }
}