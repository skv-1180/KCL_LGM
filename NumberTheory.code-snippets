{
	"Extended Euclid Algorithm": {
		"prefix": "gcd_ext",
		"scope": "cpp",
		"body": [
		  "/*storess solution of ax+by=gcd(a,b)",
		  " in (x,y) and return gcd(a,b)*/",
		  "int gcd_ext(int a, int b, int& x, int& y) {",
		  "    x = 1, y = 0;",
		  "    int x1 = 0, y1 = 1, a1 = a, b1 = b;",
		  "    while (b1) {",
		  "        int q = a1 / b1;",
		  "        tie(x, x1) = make_tuple(x1, x - q * x1);",
		  "        tie(y, y1) = make_tuple(y1, y - q * y1);",
		  "        tie(a1, b1) = make_tuple(b1, a1 - q * b1);",
		  "    }",
		  "    return a1;",
		  "}"
		],
		"description": "Extended Euclid Algorithm"
	  },
	  "Linear Diphentine Equation": {
		"prefix": "lde",
		"scope": "cpp",
		"body": [
		  "int gcd(int a, int b, int& x, int& y) {",
		  "    if (b == 0) {",
		  "        x = 1;",
		  "        y = 0;",
		  "        return a;",
		  "    }",
		  "    int x1, y1;",
		  "    int d = gcd(b, a % b, x1, y1);",
		  "    x = y1;",
		  "    y = x1 - y1 * (a / b);",
		  "    return d;",
		  "}",
		  "/*return weather solution exist or not",
		  "and store one of solution in (x0,y0) and gcd in g*/",
		  "bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
		  "    g = gcd(abs(a), abs(b), x0, y0);",
		  "    if (c % g) {",
		  "        return false;",
		  "    }",
		  "    x0 *= c / g;",
		  "    y0 *= c / g;",
		  "    if (a < 0) x0 = -x0;",
		  "    if (b < 0) y0 = -y0;",
		  "    return true;",
		  "}",
		  "//shift solution (x,y) by cnt units",
		  "void shift_solution(int & x, int & y, int a, int b, int cnt) {",
		  "    x += cnt * b;",
		  "    y -= cnt * a;",
		  "}",
		  "/*returns number of solution (x,y) of ax+by=c",
		  " x in [minx,maxx],y in [miny,maxy]*/",
		  "int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
		  "    int x, y, g;",
		  "    if (!find_any_solution(a, b, c, x, y, g))return 0;",
		  "    a /= g;b /= g;",
		  "    int sign_a = a > 0 ? +1 : -1;",
		  "    int sign_b = b > 0 ? +1 : -1;",
		  "    shift_solution(x, y, a, b, (minx - x) / b);",
		  "    if (x < minx)shift_solution(x, y, a, b, sign_b);",
		  "    if (x > maxx)return 0;",
		  "    int lx1 = x;",
		  "    shift_solution(x, y, a, b, (maxx - x) / b);",
		  "    if (x > maxx)shift_solution(x, y, a, b, -sign_b);",
		  "    int rx1 = x;",
		  "    shift_solution(x, y, a, b, -(miny - y) / a);",
		  "    if (y < miny)shift_solution(x, y, a, b, -sign_a);",
		  "    if (y > maxy)return 0;",
		  "    int lx2 = x;",
		  "    shift_solution(x, y, a, b, -(maxy - y) / a);",
		  "    if (y > maxy)shift_solution(x, y, a, b, sign_a);",
		  "    int rx2 = x;",
		  "    if (lx2 > rx2)swap(lx2, rx2);",
		  "    int lx = max(lx1, lx2);",
		  "    int rx = min(rx1, rx2);",
		  "    if (lx > rx)return 0;",
		  "    return (rx - lx) / abs(b) + 1;",
		  "}"
		],
		"description": "Linear Diphentine Equation"
	  },
	  "Fibonachi Sequence": {
		"prefix": "fibonachi",
		"scope": "cpp",
		"body": [
		  "/*Properties:",
		  "1.f(n-1)f(n+1)+f(n)f(n)=(-1)^n;",
		  "2.f(n+k)=f(k)f(n+1)+f(k-1)f(n)=>{f(2n)=f(n)[f(n+1)+f(n-1)]};",
		  "3.gcd(f(m),f(n))=f(gcd(m,n));",
		  "4.f(2k+1)=f(k)f(k)+f(k+1)f(k+1);",
		  "5.sequence f(i)mod(p) is periodic for any p.*/",
		  "//this function gives f(n)={F(n),F(n+1)};O(log(N))",
		  "pair<int, int> fib_pair(int n) {",
		  "    if (n == 0)return {0, 1};",
		  "    auto p = fib_pair(n >> 1);",
		  "    int c = p.first * (2 * p.second - p.first);",
		  "    int d = p.first * p.first + p.second * p.second;",
		  "    if (n & 1)return {d, c + d};",
		  "    else return {c, d};",
		  "}",
		  "//generates a vector of first n fibonachi numbers",
		  "vector<int>fib_vector(int n){",
		  "  vector<int>ans(n);ans[1]=1;",
		  "  for(int i=2;i<n;i++)ans[i]=ans[i-1]+ans[i-2];",
		  "  return ans;",
		  "}"
		],
		"description": "Fibonachi Sequence"
	  },
	  "Seive of Eratosthenes": {
		"prefix": "seive",
		"body": [
		  "//generate a is_prime checker vector",
		  "//TC:O(nlog(log(n))) MC:O(N)",
		  "vector<bool> is_prime(N, true);",
		  "void generate(int n){",
		  "  is_prime[0] = is_prime[1] = false;",
		  "  for (int i = 2; i * i <= n; i++) {",
		  "      if (is_prime[i]) {",
		  "          for (int j = i * i; j <= n; j += i)is_prime[j] = false;",
		  "      }",
		  "  }",
		  "}",
		  "//number of primes till n ",
		  "//TC:O(n(log(log(n))) MC:O(sqrt(n)+S)",
		  "int count_primes(int n) {",
		  "    const int S = 10000;",
		  "    vector<int> primes;",
		  "    int nsqrt = sqrt(n);",
		  "    vector<char> is_prime(nsqrt + 2, true);",
		  "    for (int i = 2; i <= nsqrt; i++) {",
		  "        if (is_prime[i]) {",
		  "            primes.push_back(i);",
		  "            for (int j = i * i; j <= nsqrt; j += i)",
		  "                is_prime[j] = false;",
		  "        }",
		  "    }",
		  "    int result = 0;",
		  "    vector<char> block(S);",
		  "    for (int k = 0; k * S <= n; k++) {",
		  "        fill(block.begin(), block.end(), true);",
		  "        int start = k * S;",
		  "        for (int p : primes) {",
		  "            int start_idx = (start + p - 1) / p;",
		  "            int j = max(start_idx, p) * p - start;",
		  "            for (; j < S; j += p)block[j] = false;",
		  "        }",
		  "        if (k == 0)block[0] = block[1] = false;",
		  "        for (int i = 0; i < S && start + i <= n; i++) {",
		  "            if (block[i])result++;",
		  "        }",
		  "    }",
		  "    return result;",
		  "}",
		  "//is_prime in [L,R] is_prime(i)=true if L+i is prime",
		  "//TC:O(R-L)log(log(R))    MC:O(sqrt(R)+R-L)",
		  "vector<char> segmentedSieve(long long L, long long R) {",
		  "    // generate all primes up to sqrt(R)",
		  "    long long lim = sqrt(R);",
		  "    vector<char> mark(lim + 1, false);",
		  "    vector<long long> primes;",
		  "    for (long long i = 2; i <= lim; ++i) {",
		  "        if (!mark[i]) {",
		  "            primes.emplace_back(i);",
		  "            for (long long j = i * i; j <= lim; j += i)mark[j] = true;",
		  "        }",
		  "    }",
		  "    vector<char> isPrime1(R - L + 1, true);",
		  "    for (long long i : primes)",
		  "        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)",
		  "            isPrime1[j - L] = false;",
		  "    if (L == 1)isPrime1[0] = false;",
		  "    return isPrime1;",
		  "}",
		  "//do same task as above",
		  "//TC:O((R-L)log(R))  MC:O(R-L)",
		  "vector<char> segmentedSieveNoPreGen(long long L, long long R) {",
		  "    vector<char> isPrime2(R - L + 1, true);",
		  "    long long lim = sqrt(R);",
		  "    for (long long i = 2; i <= lim; ++i)",
		  "        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)isPrime2[j - L] = false;",
		  "    if (L == 1)isPrime2[0] = false;",
		  "    return isPrime2;",
		  "}"
		],
		"description": "Seive of Eratosthenes"
	  },
	  "MillerRabin(Fast Prime)": {
		"prefix": "fastprime",
		"body": [
		  "//veryfastprimecheck  ",
		  "using u64 = uint64_t;",
		  "using u128 = __uint128_t;",
		  "u64 bin_exp(u64 x,u64 y,u64 mod=LONG_LONG_MAX){",
		  "    u64 ans=1;x%=mod;u128 z=1;",
		  "    while(y){",
		  "        if(y&1){",
		  "            ans=(ans*z*x)%mod;",
		  "            ans%=mod;",
		  "        }",
		  "        x=(x*z*x)%mod;",
		  "        y>>=1;",
		  "    }",
		  "    return ans;",
		  "}",
		  "bool check_composite(u64 n, u64 a, u64 d, int s) {",
		  "    u64 x = bin_exp(a, d, n);",
		  "    if (x == 1 || x == n - 1)",
		  "        return false;",
		  "    for (int r = 1; r < s; r++) {",
		  "        x = (u128)x * x % n;",
		  "        if (x == n - 1)",
		  "            return false;",
		  "    }",
		  "    return true;",
		  "};",
		  "bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.",
		  "    if (n < 2)return false;",
		  "    int r = 0;",
		  "    u64 d = n - 1;",
		  "    while ((d & 1) == 0) {",
		  "        d >>= 1;r++;",
		  "    }",
		  "",
		  "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
		  "        if (n == a)return true;",
		  "        if (check_composite(n, a, d, r))return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": "MillerRabin(Fast Prime)"
	  },
	  "Prime Factorisation": {
		"prefix": "primefactorisation",
		"scope": "cpp",
		"body": [
		  "vector<long long>leastprimedivisor;",
		  "void generate(int n){",
		  "  leastprimedivisor.resize(n+1);",
		  "  for(int i=0;i<=n;i++)leastprimedivisor[i]=i;",
		  "  for (int i = 2; i * i <= n; i++) {",
		  "      if (leastprimedivisor[i]==i){",
		  "          for(int j=i*i;j<=n;j+=i)if(leastprimedivisor[j]==j)leastprimedivisor[j]=i;   ",
		  "      }",
		  "  }",
		  "}",
		  "vector<pair<long long,long long>> primeFactorisation(long long num) {",
		  "if(!leastprimedivisor.size())generate(N);",
		  "    vector<pair<long long,long long>> factorization;",
		  "    while(leastprimedivisor[num]!=1){",
		  "        int divisor=leastprimedivisor[num];",
		  "        int power=0;",
		  "        while(num%divisor==0){",
		  "            num/=divisor;power++;",
		  "        }",
		  "        factorization.push_back({divisor,power});",
		  "    }   ",
		  "    return factorization;",
		  "}",
		  ""
		],
		"description": "Prime Factorisation"
	  },
	  "Euler Totient Function": {
		"prefix": "eulertotient",
		"scope": "cpp",
		"body": [
		  "//no. of integers in [1,n] coprime to n.",
		  "//TC:O(rqrt(n))  MC:O(1)",
		  "/*Properties:",
		  "1.phi(p)  =p-1  p==>prime",
		  "2.phi(p^k)=p^k-p^(k-1)  p==>prime",
		  "3.phi(ab)=phi(a)phi(b)  ==a,b are coprime==",
		  "4.sigma(phi(d))=n      d==>divisor on n in [1,n]",
		  "5.(a^phi(n))%n=1        <Euler Theorem>(a,m are coprime)",
		  "6.(a^n)%m=(a^(n%phi(m)))%m  ==>a,m coprime",
		  "7.(a^n)%m=(a^(phi(m)+(n%phi(m))))%m  ==>a,m general",
		  "*/",
		  "int phi(int n) {",
		  "    int result = n;",
		  "    for (int i = 2; i * i <= n; i++) {",
		  "        if (n % i == 0) {",
		  "            while (n % i == 0)n /= i;",
		  "            result -= result / i;",
		  "        }",
		  "    }",
		  "    if (n > 1)result -= result / n;",
		  "    return result;",
		  "}",
		  "//generate all phi from 1 to n;",
		  "//TC:O(nlog(log(n)))  MC:O(n)",
		  "vector<int> phis;",
		  "void phi_1_to_n(int n) {",
		  "    for (int i = 0; i <= n; i++)phis.push_back(i);",
		  "    for (int i = 2; i <= n; i++) {",
		  "        if (phis[i] == i) {",
		  "            for (int j = i; j <= n; j += i)phis[j] -= phis[j] / i;",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Euler Totient Function"
	  },
	  "Moduler Arithemetics": {
		"prefix": "mod",
		"body": [
		  "//cacl mod inverse of i wrt m",
		  "//T.C.:O(log(i)/log(log(m))) M.C.:O(1)",
		  "int inv(int i,int m) {",
		  "  i%=m;",
		  "  return i <= 1 ? i : m - (long long)(m/i) * inv(m % i,m) % m;",
		  "}",
		  "//Generates inverse mod(m) till m",
		  "//T.C.:O(m) M.C.:O(m)",
		  "vector<int>invs;",
		  "void generate_inv(int m){",
		  "    invs.resize(m);",
		  "    invs[1] = 1;",
		  "    for(int i = 2; i < m; ++i)",
		  "        invs[i] =( m - (long long)(m/i) * invs[m%i] % m)%m;",
		  "",
		  "}",
		  "//!!WARNING!!{add:extended_euclid}",
		  "//create mod inv of all arr elements mod(m)",
		  "std::vector<int> invarr(const std::vector<int> &a, int m) {",
		  "    int n = a.size();",
		  "    if (n == 0) return {};",
		  "    std::vector<int> b(n);",
		  "    int v = 1;",
		  "    for (int i = 0; i != n; ++i) {",
		  "        b[i] = v;",
		  "        v = static_cast<long long>(v) * a[i] % m;",
		  "    }",
		  "    int x, y;",
		  "    extended_euclidean(v, m, x, y);",
		  "    x = (x % m + m) % m;",
		  "    for (int i = n - 1; i >= 0; --i) {",
		  "        b[i] = static_cast<long long>(x) * b[i] % m;",
		  "        x = static_cast<long long>(x) * a[i] % m;",
		  "    }",
		  "    return b;",
		  "}",
		  "long long crt_coprimes(vector<pair<long long,long long>> const& congruences) {",
		  "    long long M = 1;",
		  "    for (auto const& congruence : congruences) {",
		  "        M *= congruence.second;",
		  "    }",
		  "    long long solution = 0;",
		  "    for (auto const& congruence : congruences) {",
		  "        long long a_i = congruence.first;",
		  "        long long M_i = M / congruence.second;",
		  "        long long N_i = inv(M_i, congruence.second);",
		  "        solution = (solution + a_i * M_i % M * N_i) % M;",
		  "    }",
		  "    return solution;",
		  "}",
		  "//Calculate n!%p",
		  "//T.C.:O(p+logp(n)) M.C.:O(p)",
		  "vector<int> f;//f[i]=i!%p",
		  "int factmod(int n, int prime) {",
		  "    f.resize(prime);",
		  "    f[0] = 1;",
		  "    //precomputation of f",
		  "    for (int i = 1; i < prime; i++)f[i] = f[i-1] * i % prime;",
		  "",
		  "    int res = 1;",
		  "    while (n > 1) {",
		  "        if ((n/prime) % 2)res = prime - res;",
		  "        res = res * f[n%prime] % prime;",
		  "        n /= prime;",
		  "    }",
		  "    return res;",
		  "}",
		  "//gives power of p=>\"prime\" in n!",
		  "//T.C.:O(p+logp(n)) M.C.:O(1)",
		  "int multiplicity_factorial(int n, int p) {",
		  "    int count = 0;",
		  "    do {",
		  "        n /= p;",
		  "        count += n;",
		  "    } while (n);",
		  "    return count;",
		  "}"
		],
		"description": "Moduler Arithemetics"
	  }
}